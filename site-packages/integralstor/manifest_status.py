
import json
import os
import shutil
import sys
import re
import netifaces
import socket
import platform
import pprint
import integralstor_utils
from integralstor_utils import config, networking, command, disks, zfs, services_management

"""
The master.manifest file contains information about what the system configuration SHOULD be. Got by scanning the system at setup time or when requested by the admin.
The master.status file contains the status of the system components as of now. By comparing against the manifest, we can tell if something is missing or new.
"""


"""
Get all info and the status about all disks including any pool on disks
"""


def get_zfs_version():
    zfs_ver = ""
    try:
        #lines, err = command.get_command_output('dmesg | grep ZFS', shell=True)
        lines, err = command.get_command_output(
            "modinfo zfs | grep -iw -e version | cut -d ':' -f 2", shell=True)
        if err:
            zfs_ver = 'Could not determine..'
        if lines and lines[0]:
            zfs_ver = 'ZFS build ' + lines[0].strip()
        else:
            zfs_ver = 'Could not determine..'
    except Exception, e:
        return None, 'Error retrieving ZFS information : %s' % str(e)
    else:
        return zfs_ver, None


def get_disk_info(rescan=False):
    return_dict = None
    try:
        return_dict, err = disks.get_disk_info_status_all(
            rescan=rescan, type='info')
        if err:
            raise Exception(err)
    except Exception, e:
        return None, 'Error retrieving disk information : %s' % str(e)
    else:
        return return_dict, None


def get_disk_status():
    return_dict = None
    try:
        return_dict, err = disks.get_disk_info_status_all(
            rescan=False, type='status')
        if err:
            raise Exception(err)
        if return_dict:
            pool_list, err = zfs.get_pools()
            if pool_list:
                for sn, disk in return_dict.items():
                    # print disk['name']
                    id, err = disks.get_disk_id(disk['name'])
                    if err:
                        raise Exception(err)
                    # print id
                    #id = disk['id']
                    found = False
                    for pool in pool_list:
                        devices_list, err = zfs.get_disks_in_component(
                            pool['config']['pool']['root'])
                        if err:
                            raise Exception(err)
                        # print 'devices list is ', devices_list
                        # print 'id is', id
                        if devices_list and id in devices_list:
                            # print 'in devices list'
                            disk['pool'] = pool['pool_name']
    except Exception, e:
        return None, 'Error retrieving disk status : %s' % str(e)
    else:
        return return_dict, None


def get_disk_info_and_status():

    all_disks = None
    try:
        all_disks, err = disks.get_disk_info_all()
        if err:
            raise Exception(err)

        if all_disks:
            pool_list, err = zfs.get_pools()
            if pool_list:
                for sn, disk in all_disks.items():
                    id = disk['id']
                    found = False
                    for pool in pool_list:
                        devices_list, err = zfs.get_disks_in_component(
                            pool['config']['pool']['root'])
                        if err:
                            raise Exception(err)
                        if devices_list and id in devices_list:
                            disk['pool'] = pool['pool_name']
    except Exception, e:
        return None, 'Error retrieving disk information and status : %s' % str(e)
    else:
        return all_disks, None


def get_pool_status():
    """Get status of all zfs pools."""
    pl = None
    try:
        pl, err = zfs.get_pools()
        if err:
            raise Exception(err)
    except Exception, e:
        return None, 'Error retrieving pool status : %s' % str(e)
    else:
        return pl, None


def get_interface_info():
    """Gets a more concise version of the interface info than networking provides."""
    d = {}
    try:
        ifaces, err = networking.get_interfaces()
        if err:
            raise Exception(err)
        # print ifaces
        if ifaces:
            for iface_name, iface in ifaces.items():
                td = {}
                td['hwaddr'] = iface['addresses']['AF_LINK'][0]['addr']
                d[iface_name] = td
    except Exception, e:
        return None, 'Error retrieving interface info : %s' % str(e)
    else:
        return d, None


def get_interface_status():
    """Gets a more concise version of the interface info and status than networking provides."""
    d = {}
    try:
        ifaces, err = networking.get_interfaces()
        if err:
            raise Exception(err)
        # print ifaces
        if ifaces:
            for iface_name, iface in ifaces.items():
                td = {}
                td['up'] = iface['up_status']
                if 'AF_INET' in iface['addresses'] and iface['addresses']['AF_INET'] and iface['addresses']['AF_INET'][0]:
                    inet_list = []
                    for inet in iface['addresses']['AF_INET']:
                        inet_dict = {}
                        if 'addr' in inet:
                            inet_dict['address'] = inet['addr']
                        if 'netmask' in inet:
                            inet_dict['netmask'] = inet['netmask']
                        if 'broadcast' in inet:
                            inet_dict['broadcast'] = inet['broadcast']
                        inet_dict['label'] = iface_name
                        inet_list.append(inet_dict)
                    td['inet'] = inet_list
                if 'bonding_master' in iface:
                    td['bonding_master'] = True
                if 'slave_to' in iface:
                    td['slave_to'] = iface['slave_to']
                if 'carrier_status' in iface:
                    td['carrier_status'] = iface['carrier_status']
                if 'bootproto' in iface:
                    td['boot_proto'] = iface['bootproto']
                d[iface_name] = td
    except Exception, e:
        return None, 'Error retrieving interface status : %s' % str(e)
    else:
        return d, None


def get_load_avg():
    """The load averages for the system along with the number of cores in order to tell if the averages are within bounds."""
    d = {}
    try:
        with open('/proc/loadavg', 'r') as f:
            line = f.readline()
            parts = line.split()
            if parts:
                d['1_min'] = float(parts[0])
                d['5_min'] = float(parts[1])
                d['15_min'] = float(parts[2])
        cores, err = get_cpu_cores()
        if err:
            raise Exception(err)
        d["cpu_cores"] = int(cores)
    except Exception, e:
        return None, 'Error retrieving load average and CPU cores info : %s' % str(e)
    else:
        return d, None


def get_cpu_cores():
    """Gets the number of cpu cores."""
    cores = -1
    try:
        with open('/proc/cpuinfo', 'r') as f:
            lines = f.readlines()
            for line in lines:
                ret = re.match('\s*cpu cores\s*:[\s]*([\d]+)$', line.strip())
                if ret:
                    grps = ret.groups()
                    if grps:
                        cores = int(grps[0].strip())
    except Exception, e:
        return None, 'Error retrieving CPU cores information: %s' % str(e)
    else:
        return cores, None


def get_mem_info_status(type='all'):
    """The total and the used memory information."""
    ret = {}
    try:
        if type not in ['info', 'status', 'all']:
            raise Exception('Invalid type passed.')
        mem_total = None
        mem_free = None
        with open('/proc/meminfo', 'r') as f:
            lines = f.readlines()
            mem_total = {}
            mem_free = {}
            for line in lines:
                if type in ['info', 'all']:
                    match = re.match(
                        'MemTotal\s*:\s+([\S]+)\s+(\S+)$', line.strip())
                    if match:
                        grps = match.groups()
                        if grps:
                            mem_total['unit'] = grps[1]
                            mem_total['value'] = int(grps[0])
                            if mem_total['unit'] == 'kB':
                                mem_total['unit'] = 'GB'
                                mem_total['value'] = int(float(
                                    mem_total['value']) / 1024 / 1024)
                            elif mem_total['unit'] == 'mB':
                                mem_total['unit'] = 'GB'
                                mem_total['value'] = int(float(
                                    mem_total['value']) / 1024)
                    if mem_total:
                        ret['mem_total'] = mem_total
                if type in ['status', 'all']:
                    match = re.match(
                        'MemFree\s*:\s+([\S]+)\s+(\S+)$', line.strip())
                    if match:
                        grps = match.groups()
                        if grps:
                            mem_free['unit'] = grps[1]
                            mem_free['value'] = int(grps[0])
                            if mem_free['unit'] == 'kB':
                                mem_free['unit'] = 'GB'
                                mem_free['value'] = int(float(
                                    mem_free['value']) / 1024 / 1024)
                            elif mem_free['unit'] == 'mB':
                                mem_free['unit'] = 'GB'
                                mem_free['value'] = int(float(
                                    mem_total['value']) / 1024)
                    if mem_free:
                        ret['mem_free'] = mem_free
            if (type in ['info', 'all'] and not mem_total):
                raise Exception('Error retrieving memory information')
            if (type in ['status', 'all'] and not mem_free):
                raise Exception('Error retrieving memory information')
    except Exception, e:
        return None, 'Error retrieving memory information: %s' % str(e)
    else:
        return ret, None


def get_services_status():
    """The status of various services."""
    s = {}
    try:
        platform, err = config.get_platform()
        if err:
            raise Exception(err)
        service_dict, err = services_management.get_sysd_services_status()
        if err:
            raise Exception(err)
        for service_name, service_info in service_dict.items():
            if service_info['info']['status']['status_str'] in ['Failed', 'Unknown State']:
                s[service_name] = [-1, service_info['info']
                                   ['status']['output_str']]
            else:
                s[service_name] = [
                    0, service_info['info']['status']['output_str']]
    except Exception, e:
        return None, 'Error retrieving services status: %s' % str(e)
    else:
        return s, None


def get_cpu_model():
    """The kind of CPU that we're running on."""
    cpu_model = None
    try:
        with open('/proc/cpuinfo', 'r') as f:
            lines = f.readlines()
            for line in lines:
                ret = re.match('\s*model name\s*:([\S\s]+)$', line.strip())
                if ret:
                    grps = ret.groups()
                    if grps:
                        cpu_model = grps[0]
                        break
    except Exception, e:
        return None, 'Error retrieving CPU model : %s' % str(e)
    else:
        return cpu_model, None


def get_ipmi_status():
    """Hardware status using IPMI."""
    ipmi_status = []
    try:
        fil = os.popen("ipmitool sdr")
        str4 = fil.read()
        lines = re.split("\r?\n", str4)
        ipmi_status = []
        for line in lines:
            l = line.rstrip()
            if not l:
                continue
            # print l
            comp_list = l.split('|')
            comp = comp_list[0].strip()
            status = comp_list[2].strip()
            hw_platform, err = config.get_hardware_platform()
            if status != "ns":
                if hw_platform and hw_platform == 'dell':
                    if ('fan' not in comp.lower()) and ('PS' not in comp) and ('voltage' not in comp.lower()) and ('current' not in comp.lower()) and (comp not in ['Inlet Temp', 'CMOS Battery', 'Pwr Consumption', 'Temp']):
                        continue
                td = {}
                td["parameter_name"] = comp_list[0].strip()
                td["reading"] = comp_list[1].strip()
                td["status"] = comp_list[2].strip()
                '''
        if comp in ["CPU Temp", "CPU1 Temperature"]:
          td["parameter_name"] = "CPU Temperature"
          td["component_name"] = "CPU"
        elif comp in ["System Temp", "MB1 Temperature"]:
          td["parameter_name"] = "System Temperature"
          td["component_name"] = "System"
        elif comp == "DIMMA1 Temp":
          td["parameter_name"] = "Memory card 1 temperature"
          td["component_name"] = "Memory card 1"
        elif comp == "DIMMA2 Temp":
          td["parameter_name"] = "Memory card 2 temperature"
          td["component_name"] = "Memory card 2"
        elif comp == "DIMMA3 Temp":
          td["parameter_name"] = "Memory card 3 temperature"
          td["component_name"] = "Memory card 3"
        elif comp == "FAN1":
          td["parameter_name"] = "Fan 1 speed"
          td["component_name"] = "Fan 1"
        elif comp == "FAN2":
          td["parameter_name"] = "Fan 2 speed"
          td["component_name"] = "Fan 2"
        elif comp == "FAN3":
          td["parameter_name"] = "Fan 3 speed"
          td["component_name"] = "Fan 3"
        elif comp == "CPU_FAN1":
          td["parameter_name"] = "CPU Fan"
          td["component_name"] = "CPU Fan"
        '''
                ipmi_status.append(td)
    except Exception, e:
        return None, 'Error retrieving IPMI information: %s' % str(e)
    else:
        return ipmi_status, None


def get_hardware_specific_info():
    return_dict = {}
    try:
        lines, err = command.get_command_output(
            'dmidecode -s system-manufacturer')
        if not err and lines and lines[0].lower() != 'none':
            return_dict['system_manufacturer'] = lines[0]
        lines, err = command.get_command_output(
            'dmidecode -s system-product-name')
        if not err and lines and lines[0].lower() != 'none':
            return_dict['system_product_name'] = lines[0]
        lines, err = command.get_command_output('dmidecode -s system-version')
        if not err and lines and lines[0].lower() != 'none':
            return_dict['system_version'] = lines[0]
        lines, err = command.get_command_output(
            'dmidecode -s system-serial-number')
        if not err and lines and lines[0].lower() != 'none':
            return_dict['system_serial_number'] = lines[0]
    except Exception, e:
        return None, 'Error retrieving hardware specific info: %s' % str(e)
    else:
        return return_dict, None


def get_hardware_specific_status():
    return_dict = {}
    try:
        hw_platform, err = config.get_hardware_platform()
        if hw_platform:
            return_dict['hw_platform'] = hw_platform
            if hw_platform == 'dell':
                return_dict['hw_platform'] = 'dell'
                from integralstor_utils.platforms import dell
                idrac_url, err = dell.get_idrac_addr()
                if idrac_url:
                    return_dict['idrac_url'] = idrac_url
    except Exception, e:
        return None, 'Error retrieving hardware specific status: %s' % str(e)
    else:
        return return_dict, None


def generate_manifest_info(rescan_for_disks=False):
    """Generate a dictionary containing all manifest information. Will be dumped into the master.manifest file in a json format."""
    manifest_dict = {}
    try:
        cpu_model, err = get_cpu_model()
        if err:
            raise Exception(err)
        manifest_dict['cpu_model'] = cpu_model

        cpu_cores, err = get_cpu_cores()
        if err:
            raise Exception(err)
        manifest_dict['cpu_cores'] = cpu_cores

        disk_info, err = disks.get_disk_info_status_all(
            rescan=rescan_for_disks, type='info')
        if err:
            raise Exception(err)
        manifest_dict['disks'] = disk_info

        meminfo, err = get_mem_info_status(type='info')
        if err:
            raise Exception(err)
        manifest_dict['memory'] = meminfo

        iface_info, err = get_interface_info()
        if err:
            raise Exception(err)
        manifest_dict['interfaces'] = iface_info

        hardware_info_dict, err = get_hardware_specific_info()
        if err:
            raise Exception(err)
        if hardware_info_dict:
            manifest_dict['hardware_specific_info'] = hardware_info_dict

        if not manifest_dict:
            raise Exception('Error getting manifest information')

    except Exception, e:
        return None, 'Error generating the manifest dictionary : %s' % str(e)
    else:
        return manifest_dict, None


def _convert_to_status_interface_dict(if_dict):
    id = {}
    try:
        # print 'interface info - ', if_dict
        id["status"] = if_dict["up"]
        if 'bonding_master' in if_dict:
            id['bonding_master'] = True
        if 'slave_to' in if_dict:
            id['slave_to'] = if_dict['slave_to']
        if 'carrier_status' in if_dict:
            id['carrier_status'] = if_dict['carrier_status']
        if "inet" in if_dict:
            id["inet"] = if_dict["inet"]
        if 'boot_proto' in if_dict and if_dict['boot_proto'] and if_dict['boot_proto'] in ['static', 'dhcp']:
            id['ip_configured'] = True
    except Exception, e:
        return None, 'Error converting to status interface dict : %s' % str(e)
    else:
        return id, None


"""
Generate a dictionary containing all status information. Will be dumped into the master.status file in a json format.
"""


def generate_status_info(path):
    status_dict = {}
    try:
        pp = pprint.PrettyPrinter(indent=4)

        # First load the status
        fqdn = socket.getfqdn()
        # Load the manifest to check for discrepencies
        try:
            with open(path, 'r') as f:
                manifest_dict = json.load(f)
        except Exception, e:
            raise Exception('Error reading the manifest file : %s' % str(e))
        # pp.pprint(md)

        # Match the status against the manifest entries for discrepencies
        status_dict["errors"] = []
        hardware_dict, err = get_hardware_specific_status()
        if err:
            raise Exception(err)
        if hardware_dict:
            status_dict['hardware_specific_status'] = hardware_dict
        node_status = 0

        # Process disk information
        disks_dict = {}
        disk_status_dict, err = disks.get_disk_info_status_all(
            rescan=False, type='status')
        if err:
            raise Exception(err)
        # print disk_status_dict.keys()
        for disk_sn, disk_info_dict in manifest_dict["disks"].items():
            # print disk_info_dict
            # print disk_sn
            dd = {}
            if disk_sn in disk_status_dict.keys():
                dd["name"] = disk_status_dict[disk_sn]["name"]
                dd["status"] = disk_status_dict[disk_sn]["status"]
                if dd['status']:
                    if ('hw_raid' not in disk_info_dict) or (not disk_info_dict['hw_raid']):
                        if (dd["status"].lowed() not in ['ok', 'passed']):
                            node_status = 1
                            status_dict["errors"].append(
                                {'subsystem_type_id': 1, 'severity_type_id': 2, 'component': disk_sn, 'alert_str': "Disk with serial number %s is reporting SMART errors." % disk_sn})
            else:
                dd['status'] = 'Disk missing'
                node_status = 1
                status_dict["errors"].append(
                    {'subsystem_type_id': 1, 'severity_type_id': 3, 'component':  disk_sn, 'alert_str':
                     "Disk with serial number %s seems to be missing." % disk_sn})
            disks_dict[disk_sn] = dd
            '''
            #Dont detect new disks here because it requires a costly disk rescan
            new_disk = False
            for td in sd[hostname]["disks"].keys():
                if td not in manifest["disks"]:
                    new_disk = True
                    status_dict["errors"].append(
                        { 'subsystem_type_id': 1, 'severity_type_id': 1, 'component' : disk_sn, 'alert_str' : 
                        "New disk detected. Disk with serial number %s  seems to be new." % td})
                    node_status = 2
            #temp_d["disks"] = disks
            temp_d["disks"] = sd[hostname]['disks']
            # pp.pprint(temp_d['disks'])
            '''
        status_dict['disks'] = disks_dict

        services_status_dict, err = get_services_status()
        if err:
            raise Exception(err)
        status_dict["services"] = services_status_dict
        if services_status_dict:
            for service_name, service_info in services_status_dict.items():
                if service_info[0] != 0:
                    status_dict['errors'].append(
                        {'subsystem_type_id': 2, 'severity_type_id': 3, 'component': service_name, 'alert_str':
                         'Service %s seems to have failed.' % service_name})
                    node_status = 1

        # Process interface information
        interfaces = {}
        interface_status_dict, err = get_interface_status()
        if err:
            raise Exception(err)
        # Check the status of existing interfaces
        for ifname, ifdict in manifest_dict["interfaces"].items():
            # Check for all initially present interfaces
            id = {}
            if ifname in interface_status_dict:
                id, err = _convert_to_status_interface_dict(
                    interface_status_dict[ifname])
                if err:
                    raise Exception(err)
            else:
                id["status"] = "Interface Missing"
                node_status = 1
                status_dict["errors"].append(
                    {'subsystem_type_id': 3, 'severity_type_id': 3, 'component': ifname, 'alert_str':
                     "Interface with name %s seems to be missing." % ifname})
            interfaces[ifname] = id
        # Check to see if there are any new interfaces
        for ifname, ifinfo in interface_status_dict.items():
            # Check for all newly created interfaces - bonds, vlans, etc
            # print 'ifname is ', ifname
            if ifname not in manifest_dict["interfaces"]:
                id, err = _convert_to_status_interface_dict(
                    interface_status_dict[ifname])
                if err:
                    raise Exception(err)
                interfaces[ifname] = id
        status_dict["interfaces"] = interfaces

        for ifname, id in status_dict['interfaces'].items():
            if ('ip_configured' in id or 'slave_to' in id)and id["status"] != 'up':
                node_status = 1
                status_dict["errors"].append(
                    {'subsystem_type_id': 3, 'severity_type_id': 3, 'component': ifname, 'alert_str':
                     "Interface %s is not up." % ifname})

        # print 'interfaces are ', status_dict['interfaces']

        mem_status_dict, err = get_mem_info_status(type='status')
        if err:
            raise Exception(err)
        status_dict['memory'] = mem_status_dict
        '''
                if sd[hostname]["memory"]["mem_total"]["unit"] == "kB":
                    sd[hostname]["memory"]["mem_total"]["value"] = str(
                        int(sd[hostname]["memory"]["mem_total"]["value"]) / 1024)
                    sd[hostname]["memory"]["mem_total"]["unit"] = "MB"
                if sd[hostname]["memory"]["mem_free"]["unit"] == "kB":
                    sd[hostname]["memory"]["mem_free"]["value"] = str(
                        int(sd[hostname]["memory"]["mem_free"]["value"]) / 1024)
                    sd[hostname]["memory"]["mem_free"]["unit"] = "MB"
                temp_d["memory"] = sd[hostname]["memory"]
        '''

        lavg, err = get_load_avg()
        if err:
            raise Exception(err)
        if lavg:
            status_dict['load_avg'] = lavg

        if fqdn:
            status_dict['fqdn'] = fqdn

        ipmi, err = get_ipmi_status()
        if err:
            raise Exception(err)
        if ipmi:
            status_dict["ipmi_status"] = ipmi

        if status_dict["load_avg"]['15_min'] >= status_dict["load_avg"]['cpu_cores']:
            status_dict["errors"].append(
                {'subsystem_type_id': 4, 'severity_type_id': 2, 'component': 'None', 'alert_str':
                 "The 15-minute load average has been high."})
            node_status = 1
            '''
                    "The 15-minute load average (%.2f) has been high." % temp_d["load_avg"]['15_min']})
            '''
        if status_dict["load_avg"]['5_min'] >= status_dict["load_avg"]['cpu_cores']:
            status_dict["errors"].append(
                {'subsystem_type_id': 4, 'severity_type_id': 2, 'component': 'None', 'alert_str':
                 "The 5-minute load average has been high."})
            '''
                    "The 5-minute load average (%.2f) has been high." % temp_d["load_avg"]['5_min']})
            '''

        if 'ipmi_status' in status_dict:
            for status_item in status_dict['ipmi_status']:
                if status_item["status"] not in ['ok', 'nr']:
                    status_dict["errors"].append(
                        {'subsystem_type_id': 5, 'severity_type_id': 2, 'component': parameter_name, 'alert_str':
                         'The %s of the %s is reporting errors' % (
                             status_item["parameter_name"], status_item["component_name"])})

        pools, err = zfs.get_pools()
        if err:
            raise Exception(err)
        if pools:
            status_dict['pools'] = pools

        component_status_dict, err = zfs.get_all_components_status(
            pools)
        if err:
            raise Exception(err)
        if component_status_dict:
            for pool_name, component_status_list in component_status_dict.items():
                msg = None
                severity_type_id = 1
                for component in component_status_list:
                    if 'status' in component and 'state' in component['status'] and component['status']['state'] != 'ONLINE':
                        if component['type'].lower() == 'pool':
                            if component['status']['state'] == 'DEGRADED':
                                severity_type_id = 2
                            else:
                                severity_type_id = 3
                        if not msg:
                            msg = "The ZFS pool '%s' has the following issue(s) : " % pool_name
                        msg += "The component %s of type '%s' has a state of '%s'. " % (
                            component['name'], component['type'], component['status']['state'])
                if msg:
                    status_dict['errors'].append(
                        {'subsystem_type_id': 6, 'severity_type_id': severity_type_id, 'component': pool_name, 'alert_str': msg})

        zfs_ver, err = get_zfs_version()
        if err:
            raise Exception(err)
        status_dict["zfs_version"] = zfs_ver

        os_ver = '%s %s' % (platform.system(), platform.release())
        status_dict["os_version"] = os_ver

        status_dict["node_status"] = node_status
        if node_status == 0:
            status_dict["node_status_str"] = "Healthy"
        elif node_status == 1:
            status_dict["node_status_str"] = "Degraded"
        elif node_status == 2:
            status_dict["node_status_str"] = "New on-node hardware detected"
        elif node_status == -1:
            status_dict["node_status_str"] = "No response. Down?"
            status_dict['errors'].append(
                {'subsystem_type_id': 99, 'severity_type_id': 3, 'component': hostname, 'alert_str':
                 'Node %s seems to be down' % hostname})

    except Exception, e:
        return None, 'Error generating status : %s' % str(e)
    else:
        return status_dict, None


def main():
    pp = pprint.PrettyPrinter(indent=4)
    #local = salt.client.LocalClient()
    #data = local.cmd('*', 'grains.item', ['hwaddr_interfaces', 'mem_total', 'fqdn', 'cpu_model', 'roles'])
    # print data
    # print generate_manifest_info()
    # generate_status_info()
    # print get_ipmi_status()
    # print get_mem_info()
    # print get_interface_status()
    # pp.pprint(get_status())
    # pp.pprint(generate_manifest_info())
    # pp.pprint(get_interface_status())
    # pp.pprint(get_services_status())
    # pp.pprint(generate_manifest_info())
    # print ret, err
    # print ret.keys()
    # pp.pprint(get_interface_status())
    # pp.pprint(get_disk_info_and_status())
    # print zfs_version()
    # generate_status_info('/opt/integralstor/integralstor/config/status/master.manifest')
    # pp.pprint(get_disk_status())
    # pp.pprint(generate_status_info(
    #    '/opt/integralstor/integralstor/config/status/master.manifest'))
    # pp.pprint(generate_status_info('/opt/integralstor/integralstor_gridcell/config/status/master.manifest'))
    pp.pprint(generate_status_info(
        '/opt/integralstor/integralstor/config/status/master.manifest'))
    #r, err = generate_status_info('/opt/integralstor/integralstor/config/status/master.manifest')
    # print r, err
    # if err:
    #  print err
    # print r.keys()
    # pp.pprint(r['integralstor-f678.integralstor.lan']['disks'])
    # pp.pprint(get_services_status())
    # print get_hardware_specific_info()


if __name__ == "__main__":
    ret = main()
    sys.exit(ret)

# vim: tabstop=8 softtabstop=0 expandtab ai shiftwidth=4 smarttab
