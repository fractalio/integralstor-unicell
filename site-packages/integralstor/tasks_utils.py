from integralstor import config, db, command, audit, scheduler_utils, datetime_utils

import re
import time
import datetime
import socket
import getpass
import os


def is_task_running(cron_task_id, task_type_id, check_execution=False):
    """Check if any entry in the tasks table with cron_task_id has
    status field value as 'running'

    args:       cron_task_id of integer type
                task_type_id of integer type
                check_execution of boolean type
                    - when set, also considers 'error-retrying' and
                    'queued' states.

    returns:    (ret1, ret2) - (True/False/None, "Error_String"/None)
                ret1:   True if a task has status as 'running', else
                        False if no task has status as 'running', or
                        None if exceptions were raised

                ret2:   None if no exceptions were raised, else
                        Error string 
    """
    is_running = False
    try:
        existing_tasks = None
        existing_tasks, err = get_tasks_by_cron_task_id(cron_task_id)
        if err is not None:
            raise Exception(err)
        if existing_tasks:
            for task in existing_tasks:
                # Check if a background task with the same cron_task_id is yet
                # to complete its replication
                if check_execution is True and str(task['status']) in ['running', 'queued', 'error-retrying'] and str(task['task_type_id']) == str(task_type_id):
                    is_running = True
                elif check_execution is False and str(task['status']) in ['running'] and str(task['task_type_id']) == str(task_type_id):
                    is_running = True

    except Exception, e:
        return None, str(e)
    else:
        return is_running, None


def create_task(description, subtask_list, task_type_id=0, cron_task_id=0, node=socket.getfqdn(), initiate_time=None, attempts=3, run_as_user_name='root', retry_interval=1):
    """Adds a task in to tasks table which performs/runs the subtask_list according to the received arguments."""
    row_id = -1
    try:
        if not description or not subtask_list:
            raise Exception("Insufficient parameters")

        now = int(time.time())
        if not initiate_time:
            initiate_time = now

        log_dir, err = config.get_tasks_log_dir_path()
        if err:
            raise Exception(err)
        if not os.path.isdir(log_dir):
            os.mkdir(log_dir)

        cmd = "insert into tasks (description,task_type_id, node, run_as_user_name, attempts, cron_task_id, retry_interval, create_time, initiate_time) VALUES ('%s','%d','%s','%s','%d','%d','%d', '%d', '%d');" % (
            description, task_type_id, node, run_as_user_name, attempts, int(cron_task_id), retry_interval, now, initiate_time)
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)

        row_id, err = db.execute_iud(db_path, [[cmd], ], get_rowid=True)
        if err:
            raise Exception(err)
        task_id = None

        if row_id:
            task_id = row_id
            log_file = '%s/%d.log' % (log_dir, row_id)
            for subtask in subtask_list:
                for description, command in subtask.iteritems():
                    # command = '%s  &> %s' % (command, log_file)
                    command = '%s &> %s; rc=$?; tail -n 200 %s > %s.TMP && mv %s.TMP %s; exit $rc' % (command, log_file, log_file, log_file, log_file, log_file)
                    cmd = "insert into subtasks (description,command,task_id) values ('%s','%s','%d');" % (
                        description, command, row_id)
                    status, err = db.execute_iud(
                        db_path, [[cmd], ], get_rowid=True)
                    if err:
                        raise Exception(
                            'Error creating scheduled command : %s' % err)
        else:
            raise Exception('Error creating scheduled task')
    except Exception, e:
        return False, ' Error adding task: %s' % e
    else:
        return task_id, None


def delete_task(task_id):
    """Terminate the task if it's running and delete the task entry

    """
    try:
        is_stopped, err = stop_task(task_id)
        if err:
            # best effort
            # only remote replication tasks can be stopped(currently)
            pass

        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)
        # Deleting entries from tasks table will also remove related
        # entries in subtasks table; cascading deletions.
        cmd_list = [['delete from tasks where task_id = %s' % task_id], ]

        status, err = db.execute_iud(db_path, cmd_list)
        if err:
            raise Exception(err)
    except Exception, e:
        return False, 'Error removing task : %s' % e
    else:
        return True, None


def get_task_pid(task_id):
    """Identify the process id of this task

    This action is applicable only for remote replication tasks(task_type_id=4)
    """
    pid = ''
    try:
        pid_dir_path, err = config.get_tasks_pid_dir()
        if err:
            raise Exception(err)
        task, err = get_task(task_id)
        if err:
            raise Exception(err)
        cron_task_id = task['cron_task_id']
        task_type_id = task['task_type_id']
        if task_type_id != 4:
            raise Exception("Not a remote replication task")
        cron_entry, err = scheduler_utils.get_cron_tasks(cron_task_id)
        if err:
            raise Exception(err)
        rr_cmd_str = str(cron_entry[0]['command']).strip()

        # extract the remote replication id
        rr_id = rr_cmd_str.split()[1]

        pid_file_path = '%s/rr.%s.pid' % (pid_dir_path, rr_id)
        ret, err = command.get_command_output(
            'cat %s' % pid_file_path, shell=True)
        if err:
            raise Exception("Could not identify the process instance")

        if ret and ret[0]:
            pid = ret[0]
        else:
            raise Exception("Could not identify the process instance")

    except Exception, e:
        return False, 'Error fetching pid: %s' % e
    else:
        return pid, None


def get_task_pgid(task_id):
    """Identify the process group id of this task

    This action is applicable only for remote replication tasks(task_type_id=4)
    """
    pgid = ''
    try:
        pgid_dir_path, err = config.get_tasks_pgid_dir()
        if err:
            raise Exception(err)
        task, err = get_task(task_id)
        if err:
            raise Exception(err)
        cron_task_id = task['cron_task_id']
        task_type_id = task['task_type_id']
        if task_type_id != 4:
            raise Exception("Not a remote replication task")
        cron_entry, err = scheduler_utils.get_cron_tasks(cron_task_id)
        if err:
            raise Exception(err)
        rr_cmd_str = str(cron_entry[0]['command']).strip()

        # extract the remote replication id
        rr_id = rr_cmd_str.split()[1]

        pgid_file_path = '%s/rr.%s.pgid' % (pgid_dir_path, rr_id)
        ret, err = command.get_command_output(
            'cat %s' % pgid_file_path, shell=True)
        if err:
            raise Exception("Could not identify the process instance")

        if ret and ret[0]:
            pgid = ret[0]
        else:
            raise Exception("Could not identify the process instance")

    except Exception, e:
        return False, 'Error fetching pgid: %s' % e
    else:
        return pgid, None


def stop_task(task_id, by_pgid=False, mark_failed=False):
    """Terminate this task

    This action is applicable only for remote replication tasks(task_type_id=4)
    """
    try:
        is_running = False
        cmd = ''
        kill_id = 0
        task, err = get_task(task_id)
        if err:
            raise Exception(err)
        if int(task['task_type_id']) != 4:
            raise Exception('Invalid task type')
        if str(task['status']) == 'running':
            is_running = True
        # Since task_id is the only readily availble identifier, use that to
        # retrieve relevant information. The only link between the task entry
        # and its corresponding remote_replication entry is cron_task_id. The
        # respective cron entry contains the remote_replication id embedded in
        # its command field; extract that to identify the pgid file which will
        # contain the process group id.
        if is_running is True:
            if by_pgid == True:
                # This kills the entire process group, task status
                # updates are not guaranteed
                kill_id, err = get_task_pgid(task_id)
                if err:
                    raise Exception(err)
                cmd = 'kill -- -%s' % kill_id
            else:
                # safely kill all proccess in the session of the passed
                # pid. In replication's case, it's the executing shell
                # script's pid which was spawned under a separate
                # session.
                kill_id, err = get_task_pid(task_id)
                if err:
                    raise Exception(err)
                cmd = 'kill $(ps -s %s -o pid= | grep -o [0-9]*)' % kill_id
            ret, err = command.get_command_output(cmd, shell=True)
            if err:
                raise Exception("Could not terminate the process group: %s" % err)
            time.sleep(5)

        # Read again to get the updated status
        task, err = get_task(task_id)
        if err:
            raise Exception(err)
        status = str(task['status'])
        attempts = task['attempts']
        audit_str = "%s" % task['description']
        status_update = ''

        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)

        if mark_failed is True:
            # regradless of the status(running or error-retrying), mark it failed.
            status_update = "update tasks set status = 'failed', attempts = '%d' where task_id = '%d' and status is not 'cancelled'" % (
                0, task['task_id'])
            status, err = db.execute_iud(
                db_path, [[status_update], ], get_rowid=True)
            if err:
                raise Exception(err)

        # If the caller(in fn process_tasks()) had not received a return code(
        # term signal 9?), status is not updated and remains 'running', so,
        # handle it here.
        if status == 'running':
            if attempts > 1:
                status_update = "update tasks set status = 'error-retrying', attempts = %d where task_id = '%d' and status is not 'cancelled'" % (
                    attempts - 1, task['task_id'])
            elif attempts == -2:
                status_update = "update tasks set status = 'error-retrying', attempts = %d where task_id = '%d' and status is not 'cancelled'" % (
                    -2, task['task_id'])
            else:
                status_update = "update tasks set status = 'failed', attempts = '%d' where task_id = '%d' and status is not 'cancelled'" % (
                    0, task['task_id'])
            status, err = db.execute_iud(
                db_path, [[status_update], ], get_rowid=True)
            if err:
                raise Exception(err)

        audit.audit("task_fail", audit_str,
                    None, system_initiated=True)

    except Exception, e:
        return False, 'Error stopping task: %s' % e
    else:
        return True, None


def delete_all_tasks():
    """Delete all entries from tasks table and terminate running tasks

    """
    try:
        tasks, err = get_tasks()
        if err:
            raise Exception(err)
        for task in tasks:
            if str(task['status']) == 'running':
                ret, err = stop_task(int(task['task_id']))
                if err:
                    # best effort
                    pass

        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)
        # Deleting entries from tasks table will also remove related
        # entries in subtasks table; cascading deletions.
        cmd_list = [['delete from tasks'], ]

        status, err = db.execute_iud(db_path, cmd_list)
        if err:
            raise Exception(err)
    except Exception, e:
        return False, 'Error removing tasks: %s' % e
    else:
        return True, None


def get_tasks(node=None):
    """Returns all entries from tasks table."""
    tasks = None
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)

        #start_time = int((datetime.datetime.now() - datetime.timedelta(minutes=minutes)).strftime("%s"))
        #end_time = int((datetime.datetime.now() + datetime.timedelta(minutes=minutes)).strftime("%s"))

        if not node:
            tasks_query = "select * from tasks order by initiate_time desc"
        else:
            tasks_query = "select * from scheduler_tasks order by initiate_time desc"

        tasks, err = db.get_multiple_rows(db_path, tasks_query)
        if err:
            raise Exception(err)
    except Exception, e:
        return None, 'Error retrieving tasks : %s' % e
    else:
        return tasks, None


def get_tasks_by_cron_task_id(cron_task_id, get_last_by=False, status_list=None):
    tasks = []
    try:
        status_qry = ''
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)

        if status_list:
            list_len = len(status_list)
            for idx, status in enumerate(status_list):
                if idx < (list_len - 1):
                    status_qry = '%s status="%s" or ' % (status_qry, str(status))
                elif idx == (list_len - 1):
                    status_qry = '%s status="%s"' % (status_qry, str(status))
            status_qry = 'and (%s)' % status_qry
        if get_last_by is False:
            query = 'select * from tasks where cron_task_id="%d" %s' % (int(
                cron_task_id), status_qry)
        else:
            query = 'select * from tasks where cron_task_id="%d" %s order by "%s" desc limit 1' % (
                int(cron_task_id), status_qry, str(get_last_by))

        tasks, err = db.get_multiple_rows(db_path, query)
        if err:
            raise Exception(err)
    except Exception, e:
        return None, 'Error retrieving tasks by cron task id: %s' % e
    else:
        return tasks, None


def get_task(task_id):
    """Get a particular entry with the passed task_id from the tasks table."""
    task = None
    try:

        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)

        cmd = "select * from tasks where task_id=='%d'" % int(task_id)
        task, err = db.get_single_row(db_path, cmd)
        if err:
            raise Exception(err)
        if not task:
            raise Exception('Selected task not found')
    except Exception, e:
        return None, 'Error retrieving task details : %s' % e
    else:
        return task, None


def get_subtasks(task_id):
    """For the given task_id, fetch all the entires from subtasks with matching task_id value."""
    subtasks = None
    try:
        query = "select * from subtasks where task_id = '%d'" % task_id

        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)

        subtasks, err = db.get_multiple_rows(db_path, query)
        if err:
            raise Exception(err)
        if not subtasks:
            raise Exception('No subtasks found for the specified task.')
    except Exception, e:
        return None, 'Error retrieving subtasks : %s' % e
    else:
        return subtasks, None

def run_task(task_id):
    try:
        task, err = get_task(task_id)
        if err:
            raise Exception(err)
        now, err = datetime_utils.get_epoch(when='now')
        if err:
            raise Exception(err)
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)


        if task['last_run_time']:
            seconds_since_last_run = (now - task['last_run_time'])
            # retry_interval is in minutes!
            if seconds_since_last_run < task['retry_interval'] * 60:
                raise Exception("Too young to attempt")

        # Mark the task as running
        cmd = "update tasks set status = 'running', last_run_time=%d where task_id = '%d'" % (
            now, task['task_id'])
        status, err = db.execute_iud(
            db_path, [[cmd], ], get_rowid=True)
        if err:
            raise Exception(err)

        audit_str = "%s" % task['description']
        audit.audit("task_start", audit_str,
                    None, system_initiated=True)

        attempts = task['attempts']
        run_as_user_name = task['run_as_user_name']

        # Now process subtasks for the task
        subtasks_query = "select * from subtasks where task_id == '%d' and (status == 'error-retrying' or status == 'queued') order by subtask_id" % task[
            'task_id']
        subtasks, err = db.get_multiple_rows(db_path, subtasks_query)
        if err:
            raise Exception(err)

        # Assume task is complete unless proven otherwise
        task_completed = True

        # Iteriate through all the unfinished subtasks related to the
        # task
        for subtask in subtasks:

            subtask_id = subtask["subtask_id"]

            status_update = "update subtasks set status = 'running' where subtask_id = '%d' and status is not 'cancelled'" % subtask_id
            status, err = db.execute_iud(
                db_path, [[status_update], ], get_rowid=True)
            if err:
                task_completed = False
                break

            # Now actually execute the command
            # This task is not meant to be executed by the current user
            # so switch to that user
            (out, return_code), err = command.execute_with_rc(
                subtask["command"], shell=True, run_as_user_name=run_as_user_name)

            if out[0]:
                output = re.sub("'", "", ''.join(out[0]))
            else:
                output = None
            if out[1]:
                error = re.sub("'", "", ''.join(out[1]))
            else:
                error = None

            if return_code == 0:
                # This means the command was successful. So update to
                # completed
                status_update = "update subtasks set status = 'completed', return_code='%d' where subtask_id = '%d' and status is not 'cancelled';" % (
                    return_code, subtask_id)
                status, err = db.execute_iud(
                    db_path, [[status_update], ], get_rowid=True)
                if err:
                    task_completed = False
                    break
                else:
                    continue
            else:
                # Subtask command failed
                if attempts > 1 or attempts == -2:
                    status_update = 'update subtasks set status = "error-retrying", return_code="%d" where subtask_id = "%d" and status is not "cancelled";' % (
                        return_code, subtask_id)
                elif attempts in [0, 1]:
                    status_update = 'update subtasks set status = "failed", return_code="%d" where subtask_id = "%d" and status is not "cancelled";' % (
                        return_code, subtask_id)
                execute, err = db.execute_iud(
                    db_path, [[status_update], ], get_rowid=True)
                task_completed = False
                break

        if task_completed:
            status_update = "update tasks set status = 'completed' where task_id = '%d'" % task[
                'task_id']
        else:
            if attempts > 1:
                status_update = "update tasks set status = 'error-retrying', attempts = %d where task_id = '%d' and status is not 'cancelled'" % (
                    attempts - 1, task['task_id'])
            elif attempts == -2:
                status_update = "update tasks set status = 'error-retrying', attempts = %d where task_id = '%d' and status is not 'cancelled'" % (
                    -2, task['task_id'])
            else:
                status_update = "update tasks set status = 'failed', attempts = '%d' where task_id = '%d' and status is not 'cancelled'" % (
                    0, task['task_id'])
        status, err = db.execute_iud(
            db_path, [[status_update], ], get_rowid=True)
        if err:
            raise Exception(err)

        if task_completed:
            audit.audit("task_complete", audit_str,
                        None, system_initiated=True)
        else:
            audit.audit("task_fail", audit_str,
                        None, system_initiated=True)


    except Exception as e:
        return False, 'Error processing task: %s' % e
    else:
        return True, None


def process_tasks(node=socket.getfqdn()):
    """When called, processes/runs subtasks of each entry from tasks table if they satisfy/pass the required checks like status, last_run_time, retries, etc."""
    '''
    TODO
        - Needs a better docstring comment beriefly explaning what the function does
    '''
    try:
        error_list = []

        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)

        # now = int(time.time())
        now, err = datetime_utils.get_epoch(when='now')
        if err:
            raise Exception(err)

        tasks_query = "select * from tasks where node == '" + node + \
            "' and (status == 'error-retrying' or status == 'queued') and (initiate_time <= '%d');" % (now)
        tasks_to_process, err = db.get_multiple_rows(db_path, tasks_query)
        if err:
            raise Exception(err)

        if tasks_to_process is not None:
            for task in tasks_to_process:
                ret, err = run_task(task['task_id'])
                if err:
                    error_list.append(str(err))

        if error_list:
            raise Exception(str(error_list))

    except Exception as e:
        return False, 'Error processing tasks: %s' % e
    else:
        return True, None


def main():
    # process_tasks()
    # get_tasks()
    # print delete_task(5)
    # print delete_all_tasks()
    # print is_task_running(1)
    # print get_task_pgid(1)
    # print stop_task(1)
    # task, err = get_task(18)
    # print task, err
    # print get_tasks_by_cron_task_id(1, status_list=['running','error-retrying'])
    print process_tasks()


if __name__ == "__main__":
    main()

# vim: tabstop=8 softtabstop=0 expandtab ai shiftwidth=4 smarttab
