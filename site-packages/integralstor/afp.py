import shutil
import ConfigParser
import os
from integralstor import services_management

def get_config_section_map(config_parser, section_name):
    dict = {}
    try:
        options = config_parser.options(section_name)
        for option in options:
            dict[option] = config_parser.get(section_name, option)
    except Exception, e:
        #print e
        return None, 'Error parsing section : %s : %s'%(section_name, e)
    else:
        return dict, None


def load_config_file():
    ''' Return a list of all AFP volumes defined in /etc/netatalk/afp.conf '''
    return_dict = {}
    try:
        config_parser = ConfigParser.ConfigParser()
        config_parser.read('/etc/netatalk/afp.conf')
        sections = config_parser.sections()
        for section in sections:
            if section.lower() == 'global':
                continue
            csm, err = get_config_section_map(config_parser, section)
            if err:
                raise Exception(err)
            #print csm
            if csm:
                if 'path' in csm.keys():
                    return_dict[section] = csm
                else:
                    raise Exception('Could not find a path for volume %s'%section)
            #print return_dict
    except Exception, e:
        return None, 'Error retrieving AFP volumes  : %s' % str(e)
    else:
        return return_dict, None

def generate_config_file(volumes_dict):
    ''' Given a dict if AFP volumes and their params, create the config file in /etc/netatalk/afp.conf '''
    try:
        cfg_file = open('/etc/netatalk/afp.conf', 'w')
        config_parser = ConfigParser.ConfigParser()
        for section_name, params in volumes_dict.items():
            print section_name, params
            config_parser.add_section(section_name)
            for param_key, param_value in params.items():
                print param_key, param_value
                config_parser.set(section_name, param_key, param_value)
        config_parser.write(cfg_file)
        cfg_file.close()
        ret, err = services_management.update_service_status('netatalk', 'reload')
        if err:
            raise Exception(err)
    except Exception, e:
        #print e
        return False, 'Error (re)creating config file : %s'%(e)
    else:
        return True, None

def rename_volume(current_name, new_name):
    ''' Given a volume name, delete it and recreate the conf file'''
    try:
        volumes_dict, err = load_config_file()
        if err:
            raise Exception(err)
        if current_name not in volumes_dict:
            raise Exception('Specified volume name does not exist in the current configuration')
        volumes_dict[new_name] = volumes_dict[current_name]
        del volumes_dict[current_name]
        result, err = generate_config_file(volumes_dict)
        if err:
            raise Exception(err)
    except Exception, e:
        #print e
        return False, 'Error renaming volume : %s'%(e)
    else:
        return True, None

def delete_volume(volume_name):
    ''' Given a volume name, delete it and recreate the conf file'''
    try:
        volumes_dict, err = load_config_file()
        if err:
            raise Exception(err)
        if volume_name not in volumes_dict:
            raise Exception('Specified volume name does not exist in the current configuration')
        del volumes_dict[volume_name]
        res, err = generate_config_file(volumes_dict)
        if err:
            raise Exception(err)
    except Exception, e:
        #print e
        return False, 'Error removing volume : %s'%(e)
    else:
        return True, None

def create_volume(volume_name, path):
    ''' Given a volume name and path, add it to the conf file'''
    try:
        volumes_dict, err = load_config_file()
        if err:
            raise Exception(err)
        if volumes_dict and 'volume_name' in volumes_dict:
            raise Exception('A volume with that name already exists')
        volumes_dict[volume_name] ={'path':path}
        res, err = generate_config_file(volumes_dict)
        if err:
            raise Exception(err)
    except Exception, e:
        #print e
        return False, 'Error creating volume : %s'%(e)
    else:
        return True, None


def main():
    pass

if __name__ == '__main__':
    main()

# vim: tabstop=8 softtabstop=0 expandtab ai shiftwidth=4 smarttab
