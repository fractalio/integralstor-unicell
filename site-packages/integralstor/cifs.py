
import os.path

from integralstor_utils import command, config, services_management, db
from integralstor import local_users

def update_auth_method(security):
    """Update the currently set authentication method in the db. """
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)
        d, err = get_auth_settings()
        if err:
            raise Exception(err)
        cl = []
        if not d:
            # Insert a default entry before they modify the settings..
            cl.append(["insert into samba_global_common (id, workgroup, netbios_name, security, include_homes_section) values (?, ?, ?, ?, ?)",
                       (1, 'workgroup', 'netbios_name', security, True,)])
        else:
            cl.append(
                ["update samba_global_common set security='%s' where id=1" % security])
        platform, err = config.get_platform()
        if err:
            raise Exception(err)
        ret, err = db.execute_iud(db_path, cl)
        if err:
            raise Exception(err)
    except Exception, e:
        return False, 'Error changing authentication method : %s' % str(e)
    else:
        return True, None

def get_auth_settings():
    """Get the current authentication settings from the db."""
    d = None
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)
        d, err = db.get_single_row(
            db_path, "select * from samba_global_common where id=1")
        if err:
            raise Exception(err)
        if d and 'security' in d and d['security'] == "ads":
            d1, err = db.get_single_row(
                db_path, "select * from samba_global_ad where id=1")
            if err:
                raise Exception(err)
            if d1:
                d.update(d1)
    except Exception, e:
        return None, 'Error loading authentication settings : %s' % str(e)
    else:
        return d, None

def update_auth_settings(d):
    """Update the authentication settings in the db to what has been passed in the dict"""
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)
        auth_settings, err = get_auth_settings()
        if err:
            raise Exception(err)
        if not auth_settings:
            cmd = ["insert into samba_global_common (id, workgroup, netbios_name, security, include_homes_section) values (?, ?, ?, ?, ?)",
                   (1, d["workgroup"], d["netbios_name"], d["security"], True,)]
        else:
            cmd = ["update samba_global_common set workgroup=?, netbios_name=?, security=?, include_homes_section=? where id = ?",
                   (d["workgroup"], d["netbios_name"], d["security"], True, 1,)]
        cmd_list = []
        cmd_list.append(cmd)
        if d["security"] == "ads":
            d1, err = db.get_single_row(
                db_path, "select * from samba_global_ad")
            if err:
                raise Exception(err)
            if d1:
                cmd = ["update samba_global_ad set realm=?, password_server=?, ad_schema_mode=?, id_map_min=?, id_map_max=?, password_server_ip=?  where id = ?",
                       (d["realm"], d["password_server"], 'rfc2307', 16777216, 33554431, d["password_server_ip"], 1, )]
                cmd_list.append(cmd)
            else:
                cmd = ["insert into samba_global_ad (realm, password_server, ad_schema_mode, id_map_min, id_map_max, password_server_ip, id) values(?,?,?,?,?,?,?)", (
                    d["realm"], d["password_server"], 'rfc2307', 16777216, 33554431, d["password_server_ip"], 1,)]
                cmd_list.append(cmd)
        # print cmd_list
        ret, err = db.execute_iud(db_path, cmd_list)
        if err:
            raise Exception(err)
    except Exception, e:
        return False, 'Error saving authentication settings : %s' % str(e)
    else:
        return True, None

def delete_auth_settings():
    """ Delete all authentication settings from the db. """
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)
        ret, err = db.execute_iud(db_path, [["delete from samba_global_common "], [
                                  "delete from samba_global_ad"]])
        if err:
            raise Exception(err)
    except Exception, e:
        return False, 'Error deleting authentication settings : %s' % str(e)
    else:
        return True, None

def generate_krb5_conf():
    """Generate the kerberos conf file used for active directory authentication."""
    try:
        d, err = get_auth_settings()
        if err:
            raise Exception(err)
        krb5_conf_path, err = config.get_krb5_conf_path()
        if err:
            raise Exception(err)
        with open("%s/krb5.conf" % krb5_conf_path, "w") as f:
            f.write(
                "; This file has been programatically generated by the IntegralStor system. Do not modify it manually!\n\n")
            f.write("[logging]\n")
            f.write("  default = FILE:/var/log/krb5libs.log\n")
            f.write("  kdc = FILE:/var/log/krb5kdc.log\n")
            f.write("  admin_server = FILE:/var/log/kadmind.log\n")

            f.write("\n[libdefaults]\n")
            f.write("  default_realm = %s\n" % d["realm"].upper())
            f.write("\n[realms]\n")
            f.write("    %s = {\n" % d["realm"].upper())
            f.write("    kdc = %s\n" % d["password_server"])
            f.write("    admin_server = %s\n" % d["password_server"])
            f.write("  }\n")
            f.write("\n[domain_realm]\n")
            f.write("  .%s = %s\n" % (d["realm"].lower(), d["realm"].upper()))
            f.write("  %s = %s\n" % (d["realm"].lower(), d["realm"].upper()))
    except Exception, e:
        return False, 'Error generating kerberos configuration : %s' % str(e)
    else:
        return True, None


def get_share_info(mode, index):
    """Get the info for a share either based on name or by db id"""
    d = None
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)
        query = None
        if mode == "by_id":
            query = "select * from samba_shares where share_id = %s" % index
        else:
            query = "select * from samba_shares where name = %s" % index
        d, err = db.get_single_row(db_path, query)
        if err:
            raise Exception(err)

    except Exception, e:
        return None, 'Error loading CIFS share information : %s' % str(e)
    else:
        return d, None

def update_share(share_id, name, comment, guest_ok, read_only, path, browseable, users, groups, hosts_allow=None, hosts_deny=None):
    """Used to update the information about an existing share in the db."""
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)
        platform, err = config.get_platform()
        if err:
            raise Exception(err)

        cmd_list = []
        cmd_list.append(["update samba_shares set comment=?, read_only=?, guest_ok=?, browseable=?, hosts_allow=?, hosts_deny=? where share_id=?",
                         (comment, read_only, guest_ok, browseable, hosts_allow, hosts_deny, share_id, )])
        ret, err = db.execute_iud(db_path, cmd_list)
        if err:
            raise Exception(err)

    except Exception, e:
        return False, 'Error saving CIFS share : %s' % str(e)
    else:
        return True, None

def delete_share(share_id):
    """Delete a share from the db."""
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)
        platform, err = config.get_platform()
        if err:
            raise Exception(err)

        cmd_list = []
        cmd_list.append(
            ["delete from samba_shares where share_id=?", (share_id, )])

        ret, err = db.execute_iud(db_path, cmd_list)
        if err:
            raise Exception(err)
    except Exception, e:
        return False, 'Error deleting CIFS share : %s' % str(e)
    else:
        return True, None

def create_share(name, comment, guest_ok, read_only, path, display_path, browseable, users, groups, vol, hosts_allow=None, hosts_deny=None):
    """Create a new share in the db."""
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)
        platform, err = config.get_platform()
        if err:
            raise Exception(err)
        d, err = get_auth_settings()
        if err:
            raise Exception(err)
        if not d:
            raise Exception(
                "Authentication settings not set. Please set authentication settings before creating shares.")
        shl, err = get_shares_list()
        if err:
            raise Exception(err)
        if shl:
            for sh in shl:
                if sh["name"] == name:
                    raise Exception("A share with that name already exists")
        share_id, err = db.execute_iud(db_path, [["insert into samba_shares (name, vol, path, display_path, comment, read_only, guest_ok, browseable, share_id, hosts_allow, hosts_deny) values (?,?, ?,?,?,?,?,?,NULL,?,?)", (
            name, vol, path, display_path, comment, read_only, guest_ok, browseable, hosts_allow, hosts_deny,)]], True)
        if err:
            raise Exception(err)
        # print share_id, err

    except Exception, e:
        return False, 'Error creating CIFS share : %s' % str(e)
    else:
        return True, None

def get_shares_list():
    """Load the list of currently created shares from the db. """
    l = []
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)
        l, err = db.get_multiple_rows(db_path, 'select * from samba_shares')
        if err:
            raise Exception(err)
    except Exception, e:
        return None, 'Error loading CIFS shares list : %s' % str(e)
    else:
        return l, None

def delete_all_shares():
    """Delete all shares from the db."""
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)
        platform, err = config.get_platform()
        if err:
            raise Exception(err)

        cmd_list = []
        cmd_list.append(["delete from samba_shares "])

        ret, err = db.execute_iud(db_path, cmd_list)
        if err:
            raise Exception(err)
    except Exception, e:
        return False, 'Error deleting all CIFS shares : %s' % str(e)
    else:
        return True, None

def get_shares_on_subpath(subpath):
    """This is used to find all shares on a particular sub path and is used to make sure we dont delete that path if shares exist."""
    l = []
    try:
        if not subpath.startswith('/'):
            subpath = '/%s' % subpath
        if not subpath.endswith('/'):
            subpath += '/'
        share_list, err = get_shares_list()
        if err:
            raise Exception(err)
        if share_list:
            for share in share_list:
                share_path = share['path']
                if not share_path.endswith('/'):
                    share_path += '/'
                if subpath in share_path:
                    l.append(share)
    except Exception, e:
        return None, 'Error retrieving shares on subpath: %s' % str(e)
    else:
        return l, None

def generate_share_header(f, share_name):
    """Generate the header section for a share in smb.conf."""
    try:
        if not f:
            raise Exception('No file handle passed')
        f.write("\n[%s]\n" % share_name)
    except Exception, e:
        return False, 'Error generating CIFS configuration file, shares header section : %s' % str(e)
    else:
        return True, None

def generate_global_section(f, d, extra_global_param_lines=None):
    """Generates the global section."""
    try:
        # print d
        if not f:
            raise Exception('No file handle passed')

        f.write("  server string = IntegralSTOR File server\n")
        f.write('  shadow: snapdir = .zfs/snapshot\n')
        f.write('  shadow: sort = desc\n')
        f.write('  shadow: format = zfs-auto-snap_%Y-%m-%d-%H%M\n')

        f.write('  vfs objects = acl_xattr\n')
        f.write('  map acl inherit = Yes\n')
        f.write('  store dos attributes = Yes\n')
        f.write('  nt acl support = Yes\n')
        f.write('  acl map full control = Yes\n')

        # Kill old sessions when request for new session is received from the same IP.
        # By activating this option, we ensure that all locks associated with an old
        # session will be released when a new session is established. However, this
        # has undesirable effects, if multiple clients share the same IP address
        # (e.g. because NAT is in use). However, in the LAN it is usually safe to
        # assume that every client will contact the server with its own IP
        # address.
        f.write('  reset on zero vc = yes\n')

        f.write("  log file = /var/log/smblog.vfs\n")
        #f.write("  log level=5\n")
        f.write("  log level=1 acls:3 locking:3\n")
        f.write("  oplocks=yes\n")
        f.write("  ea support=yes\n")
        f.write("  level2 oplocks=yes\n")
        f.write("  posix locking=no\n")
        f.write("  load printers = no\n")
        f.write("  printing = bsd\n")
        f.write("  printcap name = /dev/null\n")
        f.write("  disable spoolss = yes\n")
        f.write("  map to guest = bad user\n")
        f.write("  idmap config *:backend = tdb\n")
        if 'workgroup' in d:
            f.write("  workgroup = %s\n" % d["workgroup"].upper())
        #f.write("  netbios name = %s\n"%d["netbios_name"].upper())
        if d["security"] == "ads":
            f.write("  security = ADS\n")
            f.write("  preferred master = no\n")
            f.write("  encrypt passwords = yes\n")
            f.write("  winbind enum users  = yes\n")
            f.write("  winbind enum groups = yes\n")
            f.write("  winbind use default domain = yes\n")
            f.write("  winbind nested groups = yes\n")
            f.write("  winbind separator = +\n")
            f.write("  local master = no\n")
            f.write("  domain master = no\n")
            f.write("  wins proxy = no\n")
            f.write("  dns proxy = no\n")
            f.write("  winbind nss info = rfc2307\n")
            f.write("  winbind trusted domains only = no\n")
            f.write("  winbind refresh tickets = yes\n")
            f.write("  map untrusted to domain = Yes\n")
            if 'realm' in d:
                f.write("  realm = %s\n" % d["realm"].upper())
            if 'workgroup' in d:
                f.write("  idmap config %s:default = yes\n" %
                        d["workgroup"].upper())
                f.write("  idmap config %s:backend = ad\n" %
                        d["workgroup"].upper())
                if 'ad_schema_mode' in d:
                    f.write("  idmap config %s:schema_mode = %s\n" %
                            (d["workgroup"].upper(), d["ad_schema_mode"]))
                f.write("  idmap config %s:base_rid = 0\n" %
                        d["workgroup"].upper())
        f.write("  idmap config *:range = 16777216-33554431\n")
        if extra_global_param_lines:
            for line in extra_global_param_lines:
                f.write("  %s\n" % line)
    except Exception, e:
        return False, 'Error generating CIFS configuration file, common global section : %s' % str(e)
    else:
        return True, None



def generate_share_body(f, workgroup, path, read_only, browseable, comment, auth_method, extra_share_param_lines=None, hosts_allow=None, hosts_deny=None):
    """Generate the share body in smb.conf."""
    try:
        if not f:
            raise Exception('No file handle passed')
        f.write('  vfs objects = shadow_copy2\n')

        f.write('  inherit permissions = yes\n')
        f.write('  inherit acls = yes\n')
        if comment:
            f.write("  comment = %s\n" % comment)
        f.write("  path = %s\n" % path)
        f.write("  create mask = 0660\n")
        f.write("  kernel share modes = no\n")
        f.write("  directory mask = 0770\n")
        if hosts_allow:
            f.write('  hosts allow = %s\n' % hosts_allow)
        if hosts_deny:
            f.write('  hosts deny = %s\n' % hosts_deny)

        if read_only:
            t = "yes"
        else:
            t = "no"
        f.write("  read only = %s\n" % t)

        if browseable:
            t = "yes"
        else:
            t = "no"
        f.write("  browseable = %s\n" % t)
        if extra_share_param_lines:
            for line in extra_share_param_lines:
                f.write("  %s\n" % line)
    except Exception, e:
        return False, 'Error generating CIFS configuration file, common share body section : %s' % str(e)
    else:
        return True, None


def generate_share_section(f, share_name, workgroup, path, read_only, browseable, comment, auth_method, extra_share_param_lines=None, hosts_allow=None, hosts_deny=None):
    try:
        if not f:
            raise Exception('No file handle passed')
        ret, err = generate_share_header(f, share_name)
        if err:
            raise Exception(err)
        ret, err = generate_share_body(
            f, workgroup, path, read_only, browseable, comment, auth_method, extra_share_param_lines, hosts_allow=hosts_allow, hosts_deny=hosts_deny)
        if err:
            raise Exception(err)

    except Exception, e:
        return False, 'Error generating CIFS configuration file, shares section : %s' % str(e)
    else:
        return True, None

def generate_global_header(f):
    """Generates the global header.."""
    try:
        if not f:
            raise Exception('No file handle passed')
        f.write("; This file has been programatically generated by the IntegralStor system. Do not modify it manually!\n\n")
        f.write("[global]\n")
    except Exception, e:
        return False, 'Error generating CIFS configuration file, global header section : %s' % str(e)
    else:
        return True, None

def generate_smb_conf():
    try:
        d, err = get_auth_settings()
        if err:
            raise Exception(err)
        smb_conf_path, err = config.get_smb_conf_path()
        if err:
            raise Exception(err)
        config_dir, err = config.get_config_dir()
        if err:
            raise Exception(err)

        # For customer specific or non configurable smb.conf lines
        extra_share_param_lines = None
        extra_global_param_lines = None
        if os.path.isfile('%s/customer_specific/extra_smb_share_params.conf' % config_dir):
            with open('%s/customer_specific/extra_smb_share_params.conf' % config_dir, 'r') as f1:
                extra_share_param_lines = f1.readlines()
        if os.path.isfile('%s/customer_specific/extra_smb_global_params.conf' % config_dir):
            with open('%s/customer_specific/extra_smb_global_params.conf' % config_dir, 'r') as f1:
                extra_global_param_lines = f1.readlines()
        # print extra_share_param_lines
        # print extra_global_param_lines
        with open("%s/smb.conf" % smb_conf_path, "w+") as f:
            ret, err = generate_global_header(f)
            if err:
                raise Exception(err)
            ret, err = generate_global_section(
                f, d, extra_global_param_lines)
            if err:
                raise Exception(err)
            shl, err = get_shares_list()
            if err:
                raise Exception(err)
            if shl:
                for share in shl:
                    ret, err = generate_share_section(
                        f, share["name"], d["workgroup"], share["path"], share["read_only"], share["browseable"], share["comment"], d["security"], extra_share_param_lines, share['hosts_allow'], share['hosts_deny'])
                    if err:
                        raise Exception(err)
        ret, errors = reload_configuration()
        if errors:
            raise Exception(errors)
    except Exception, e:
        return False, 'Error generating CIFS configuration : %s' % str(e)
    else:
        return True, None


def reload_configuration():
    try:
        cmd_to_run = 'smbcontrol all reload-config'
        lines, err = command.get_command_output(cmd_to_run)
        if err:
            raise Exception(err)
        ret, err = services_management.update_service_status(
            'winbind', 'restart')
        if err:
            raise Exception(err)
    except Exception, e:
        return False, 'Error reloading CIFS configuration : %s' % str(e)
    else:
        return True, None


def kinit(user, pswd, realm):
    try:
        cmd_to_run = 'echo "%s" | kinit %s@%s' % (pswd, user, realm.upper())
        # print cmd_to_run
        lines, err = command.get_command_output(cmd_to_run, shell=True)
        # print lines, err
        if err:
            raise Exception(err)
    except Exception, e:
        return False, 'Error initializing kerberos : %s' % str(e)
    else:
        return True, None


def net_ads_join(user, pswd, password_server):
    try:
        cmd_to_run = "net ads join -U %s%%%s" % (user, pswd)
        # print 'Running %s'%cmd_to_run
        lines, err = command.get_command_output(cmd_to_run)
        if err:
            raise Exception(err)
    except Exception, e:
        return False, 'Error joining AD : %s' % str(e)
    else:
        return True, None

def get_ad_users_or_groups(type):
    """Issue an active directory command that gets all users and groups to display in share creation/editing."""
    o = None
    try:
        d, err = get_auth_settings()
        if err:
            raise Exception(err)
        workgroup = d['workgroup']
        if type and type == "users":
            o, err = command.get_command_output(
                'wbinfo -u --domain=%s' % workgroup)
            if err:
                raise Exception(err)
        elif type and type == "groups":
            o, err = command.get_command_output(
                'wbinfo -g --domain=%s' % workgroup)
            if err:
                raise Exception(err)
        else:
            raise Exception("Unknown type specified.")
        # print '%s - '%type, o

    except Exception, e:
        return None, 'Error retrieving Active Directory Users/Groups : %s' % str(e)
    else:
        return o, None



def _get_user_or_group_list(type):
    ret = None
    try:
        d, err = get_auth_settings()
        if err:
            raise Exception(err)
        if not d:
            raise Exception(
                "Unspecified authentication method. Could not retrieve users")
        elif d["security"] == "users":
            if type and type == "users":
                l, err = local_users.get_local_users()
                if err:
                    raise Exception(err)
                if l:
                    ret = []
                    for ld in l:
                        ret.append(ld["username"])
            else:
                l, err = local_users.get_local_groups()
                if err:
                    raise Exception(err)
                if l:
                    ret = []
                    for ld in l:
                        ret.append(ld["grpname"])
        elif d["security"] == "ads":
            if type and type == "users":
                ret, err = get_ad_users_or_groups("users")
                if err:
                    raise Exception(err)
            elif type and type == "groups":
                ret, err = get_ad_users_or_groups("groups")
                if err:
                    raise Exception(err)
        else:
            raise Exception(
                "Unsupported authentication method. Could not retrieve users")
    except Exception, e:
        return None, 'Error retrieving user of group list : %s' % str(e)
    else:
        return ret, None


def get_user_list():
    ret = None
    try:
        ret, err = _get_user_or_group_list("users")
        if err:
            raise Exception(err)
    except Exception, e:
        return None, 'Error retrieving users list :%s' % str(e)
    else:
        return ret, None


def get_group_list():
    ret = None
    try:
        ret, err = _get_user_or_group_list("groups")
        if err:
            raise Exception(err)
    except Exception, e:
        return None, 'Error retrieving groups list :%s' % str(e)
    else:
        return ret, None


def main():
    with open('/tmp/z', 'w') as f:
        _generate_integralstor_specific_share_body(f)
    pass


if __name__ == "__main__":
    main()

# vim: tabstop=8 softtabstop=0 expandtab ai shiftwidth=4 smarttab
