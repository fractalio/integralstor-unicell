import os
import time
import pytz
import datetime
import shlex
import subprocess


def get_tz_updated_env():
    env = None
    try:
        tz = None
        tz_str = os.path.realpath('/etc/localtime')
        if not tz_str:
            raise Exception("Error getting timezone string")
        if 'utc' in tz_str.lower():
            tz = 'UTC'
        else:
            components = tz_str.split('/')
            if components:
                tz = '%s/%s' % (
                    components[-2], components[-1])
            else:
                raise Exception("Error getting timezone string")

        env = os.environ.copy()
        env['TZ'] = tz
    except Exception, e:
        return None, 'Error retrieving time zone updated environment : %s' % str(e)
    else:
        return env, None


def get_command_output(cmd, shell=False):
    cmd_output = None
    try:
        ret = None
        rc = -1
        if not cmd:
            raise Exception('No command supplied')

        env, err = get_tz_updated_env()
        if err:
            raise Exception(err)

        if shell:
            comm_list = cmd
        else:
            # Converting to str as the older python version of shlex in
            # gridcell does not support unicode
            comm_list = shlex.split(str(cmd))
            # print 'comm_list is ', comm_list

        proc = subprocess.Popen(
            comm_list, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=shell, env=env)
        ret = proc.communicate()

        if proc:
            rc = proc.returncode
        if rc == 0:
            if ret:
                cmd_output = ret[0]
    except Exception, e:
        return None, 'Error executing command "%s" : %s' % (cmd, str(e))
    else:
        return cmd_output, None


def get_epoch(when='now', num_previous_days=0):
    ret = None
    try:
        if when not in ['now', 'midnight']:
            raise Exception('Invalid when parameter specified')
        if when == 'now':
            ret = int(time.time()) - num_previous_days * 24 * 60 * 60
        elif when == 'midnight':
            midnight = datetime.datetime.combine(
                datetime.date.today(), datetime.time.min)
            reqd_midnight = midnight - \
                datetime.timedelta(days=num_previous_days)
            ret = int(reqd_midnight.strftime('%s'))
    except Exception, e:
        return None, 'Error retrieving epoch UTC time : %s' % str(e)
    else:
        return ret, None


def convert_from_epoch(secs, return_format='datetime', str_format='%c', to='local'):
    ret = None
    try:
        if return_format not in ['datetime', 'str']:
            raise Exception('Invalid return format specified')
        if to not in ['local', 'utc']:
            raise Exception('Invalid convert to timezone specified')
        if to == 'local':
            local_tz_dict, err = get_system_timezone()
            if err:
                raise Exception(err)
            tz = pytz.timezone(local_tz_dict['timezone_str'])
        else:
            tz = pytz.utc

        d = datetime.datetime.fromtimestamp(secs, tz)
        if return_format == 'str':
            ret = d.strftime(str_format)
        else:
            ret = d
    except Exception, e:
        return None, 'Error converting epoch time to local time %s' % str(e)
    else:
        return ret, None


def update_system_date_time(system_date, system_time, system_timezone):
    return_dict = {}
    try:
        if system_timezone is not None:
            cmd = 'timedatectl set-timezone %s' % system_timezone
            ret, err = get_command_output(cmd, shell=True)
            if err:
                raise Exception(err)
            return_dict['timezone_set'] = True
            return_dict['timezone_set_to'] = system_timezone

        if system_time is not None:
            unset_ntp = 'timedatectl set-ntp false'
            ret, err = get_command_output(unset_ntp, shell=True)
            if err:
                raise Exception("Could not disable NTP sync")

            cmd = 'timedatectl set-time %s' % system_time
            ret, err = get_command_output(cmd, shell=True)
            if err:
                raise Exception(err)
            return_dict['time_set'] = True
            return_dict['time_set_to'] = system_time

        if system_date is not None:
            unset_ntp = 'timedatectl set-ntp false'
            ret, err = get_command_output(unset_ntp, shell=True)
            if err:
                raise Exception("Could not disable NTP sync")

            date_component = system_date.split("/")
            if len(date_component) != 3:
                raise Exception(
                    "The input date format is not correct (Ex: MM/DD/YYYY)")
            system_date = '%s-%s-%s' % (date_component[2],
                                        date_component[0], date_component[1])
            time_str, err = get_command_output("date +%T", shell=True)
            if err:
                raise Exception(err)
            cmd = "timedatectl set-time '%s %s'" % (system_date, time_str.strip())
            ret, err = get_command_output(cmd, shell=True)
            if err:
                raise Exception(err)
            return_dict['date_set'] = True
            return_dict['date_set_to'] = system_date

    except Exception, e:
        return None, 'Error updating date/time/timezone: %s' % str(e)
    else:
        return return_dict, None


def get_system_timezone():
    return_dict = {}
    try:
        is_utc = False
        cmd = "timedatectl | grep 'Time' | grep -oE '(\S+/.+$)'"
        system_timezone, err = get_command_output(cmd, shell=True)
        if err or not system_timezone:
            #cmd = "timedatectl | grep 'Time' | grep -oE '(\S+UTC.+$)'"
            cmd = "timedatectl | grep 'Time' | grep UTC"
            utc_timezone, err = get_command_output(cmd, shell=True)
            if err:
                raise Exception(err)
            if utc_timezone:
                is_utc = True
        if is_utc:
            return_dict['system_timezone'] = 'UTC (UTC, +0000)'
            return_dict['system_timezone_code'] = 'UTC'
            return_dict['timezone_str'] = 'UTC'
        else:
            stz_str = system_timezone.strip()
            return_dict['system_timezone'] = stz_str
            brackets_pos = stz_str.find('(')
            if brackets_pos:
                comma_pos = stz_str.find(',')
                stz_code = stz_str[brackets_pos + 1:comma_pos]
                return_dict['system_timezone_code'] = stz_code
            path = os.path.realpath('/etc/localtime')
            components = path.split('/')
            if components:
                return_dict['timezone_str'] = '%s/%s' % (
                    components[-2], components[-1])
            else:
                raise Exception('Unknown timezone')
    except Exception, e:
        return None, 'Error retrieving timezone : %s' % str(e)
    else:
        return return_dict, None


def main():
    ep, err = get_epoch(when='now', num_previous_days=1)
    #ep, err = get_epoch(when='midnight', num_previous_days=1)
    print ep, err
    '''
    dt, err = convert_from_epoch(ep, return_format='datetime', str_format = '%c', to='utc')
    print dt, err
    '''
    dt, err = convert_from_epoch(
        ep, return_format='str', str_format='%c', to='utc')
    print 'utc', dt, err
    '''
    dt, err = convert_from_epoch(ep, return_format='datetime', str_format = '%c', to='local')
    print dt, err
    '''
    dt, err = convert_from_epoch(
        ep, return_format='str', str_format='%c', to='local')
    print 'local', dt, err
    #output, err = update_date_time("02/02/2020", None)
    #output, err = update_date_time("02/02/2020", "15:15")
    # output, err = update_date_time("02/02/2020". "15:15")
    # print output,err


if __name__ == '__main__':
    """
    print get_system_timezone()
    output_time, err = get_command_output("date +%T", shell=True)
    print output_time
    print output_time.strip()
    print get_tz_updated_env()
    """
    print get_system_timezone()
    print get_tz_updated_env()
    pass

# vim: tabstop=8 softtabstop=0 expandtab ai shiftwidth=4 smarttab
